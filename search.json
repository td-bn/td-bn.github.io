[
  {
    "objectID": "home/index.html",
    "href": "home/index.html",
    "title": "Welcome",
    "section": "",
    "text": "I am a Telwain Daand.\nI move around in circles trying to generate value."
  },
  {
    "objectID": "blockchain/tdDEX.html",
    "href": "blockchain/tdDEX.html",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "",
    "text": "The tbDEX protocol facilitates the formation of networks of mutual trust between counterparties that are not centrally controlled; it allows participants to negotiate trust directly with each other (or rely on mutually trusted third-parties to vouch for counterparties), and price their exchanges to account for perceived risk and specific requirements."
  },
  {
    "objectID": "blockchain/tdDEX.html#what-is-the-aim",
    "href": "blockchain/tdDEX.html#what-is-the-aim",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "What is the aim?",
    "text": "What is the aim?\n\nbe a protocol for discovering liquidity and exchanging assets (such as bitcoin, fiat money, crypto assets or real world goods)\nutilize decentralized identity (DID) and verifiable credentials(VCs) to establish the provenance of identity in the real world\nprovides the infrastructure necessary to create a ubiquity of on-ramps and off-ramps directly between the fiat and crypto financial systems without the need for centralized intermediaries and trust brokers"
  },
  {
    "objectID": "blockchain/tdDEX.html#foundations",
    "href": "blockchain/tdDEX.html#foundations",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "Foundations",
    "text": "Foundations\n\nDIDs\n\nare a new type of identifier that enables verifiable, decentralized digital identity\nA DID refers to any subject (e.g., a person, organization, thing, data model, abstract entity, etc.) determined by the controller of the DID.\nIn contrast to typical federated identifiers, DIDs have been designed so they may be decoupled from centralized registries, identity providers, and certificate authorities.\nwhile other parties may be used to help enable the discovery of information related to a DID, the design enables the owner of a DID to prove control over it without requiring permission from any other party\n\n\n\nVCs\n\nThe Verifiable Credentials specification provides a standard way to express credentials across the digital world in a way that is cryptographically secure, privacy respecting, and machine verifiable.\nZK tech can further advance privacy and safety by preventing linkability across disclosures, reducing the amount of data disclosed, and in some cases removing the need to expose raw data values at all.\n\n\n\nIdentity Hubs\n\nFor entities to exchange messages and data for credential, app, or service flows, they need an interface through which to store, discover, and fetch data related to the flows and experiences they are participating in\nIdentity Hubs are a data storage and message relay mechanism entities can use to locate public or permissioned private data related to a given DID\nThis enables the owning entity to secure, manage, and transact their data with others without reliance on location or provider-specific infrastructure, interfaces, or routing mechanisms.\nIdentity Hubs feature semantically encoded message and data interfaces that provide inferential APIs any party can interact with simply by knowing the semantic type of data they wish to exchange. A diverse set of interactions and flows can be modeled within these interfaces by externally codifying sets of message schemas and processing directives to form meta-protocols."
  },
  {
    "objectID": "blockchain/tdDEX.html#participants",
    "href": "blockchain/tdDEX.html#participants",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "Participants",
    "text": "Participants\n\nIssuers of VCs\n\nIssuers are the source of VCs. Both individuals and organizations can be the source of VCs.\n\ne.g: a reputable organization that already conducts KYC checks could begin issuing a KYC credential to individuals\n\n\n\n\nParticipating Financial Institutions(PFIs)\n\nentities that provide liquidity services on the tdDEX network\neach PFI will be identified via DIDs and VCs\n\n\n\nWallets\n\nact as agents for individuals or institutions by facilitating exchanges with PFIs\nprovides:\n\nProviding secure encrypted storage for VCs\nPFI discovery by crawling identity hubs\napplying signatures and storing history"
  },
  {
    "objectID": "blockchain/tdDEX.html#protocol",
    "href": "blockchain/tdDEX.html#protocol",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "Protocol",
    "text": "Protocol\nDivided into:\n\nRequest for Quote(RFQ): wallet broadcasts its intent to seek PFIs to exchange\nMessaging Protocol: P2P negotiation protocol which permits secure communication between a wallet and a PFI, to exchange required data and execute a transaction\n\n\nTopology and communication flow"
  },
  {
    "objectID": "fastai/lesson_1.html",
    "href": "fastai/lesson_1.html",
    "title": "Is it a duck or a swan?",
    "section": "",
    "text": "Install dependencies\n\n!pip install -Uqq fastai duckduckgo_search\n\n\n\nDefine a function to search for images on DDG. Search for 90 images by default.\n\nfrom duckduckgo_search import ddg_images\nfrom fastcore.all import *\n\ndef search_images(term, max_images=90):\n    print(f\"Searching for '{term}'\")\n    return L(ddg_images(term, max_results=max_images)).itemgot('image')\n\n\n\nLets see the an example of the URL we find using the above function\n\nurls = search_images('duck', max_images=1)\nurls[0]\n\nSearching for 'duck'\n\n\n'http://3.bp.blogspot.com/--XA3iMvaJLY/Tw_GykPs-eI/AAAAAAAAEgU/EmFKS7Cz5xQ/s1600/Duck-04.jpg'\n\n\n\n\nWhat does this image look like? Is it actually a duck?\n\nfrom fastdownload import download_url\ndest = 'duck.jpg'\ndownload_url(urls[0], dest, show_progress=False)\n\nfrom fastai.vision.all import *\nim = Image.open(dest)\nim.to_thumb(256,256)\n\n\n\n\n\n\nHow about a swan?\n\ndownload_url(search_images('swan', max_images=1)[0], 'swan.jpg', show_progress=False)\nImage.open('swan.jpg').to_thumb(256,256)\n\nSearching for 'swan'\n\n\n\n\n\n\n\nLooks like we are on the right path. So go ahead and download 90 of each. Might take a bit of time.\n\nsearches = 'duck','swan'\npath = Path('duck_or_swan')\nfrom time import sleep\n\nfor o in searches:\n    dest = (path/o)\n    dest.mkdir(exist_ok=True, parents=True)\n    download_images(dest, urls=search_images(f'{o} photo'))\n    sleep(30)  # Pause between searches to avoid over-loading server\n    resize_images(path/o, max_size=400, dest=path/o)\n\nSearching for 'duck photo'\nSearching for 'swan photo'\n\n\n\n\nRemove images that didnâ€™t get downloaded properly\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\nlen(failed)\n\n1\n\n\n\n\nThe easiest way to use FastAI is to use define a DataBlock. We load the data from the path.\n\ndls = DataBlock(\n    blocks=(ImageBlock, CategoryBlock), \n    get_items=get_image_files, \n    splitter=RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    item_tfms=[Resize(192, method='squish')]\n).dataloaders(path, bs=32)\n\ndls.show_batch(max_n=6)\n\n\n\n\n\n\nFine tune the pre-trained resnet18 model for our data.\n\nlearn = vision_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(3)\n\n/Users/bnabi/miniforge3/envs/invokeai/lib/python3.10/site-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and will be removed in 0.15, please use 'weights' instead.\n  warnings.warn(\n/Users/bnabi/miniforge3/envs/invokeai/lib/python3.10/site-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and will be removed in 0.15. The current behavior is equivalent to passing `weights=ResNet18_Weights.IMAGENET1K_V1`. You can also use `weights=ResNet18_Weights.DEFAULT` to get the most up-to-date weights.\n  warnings.warn(msg)\n\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      error_rate\n      time\n    \n  \n  \n    \n      0\n      1.222246\n      0.440960\n      0.290323\n      00:04\n    \n  \n\n\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      error_rate\n      time\n    \n  \n  \n    \n      0\n      0.402388\n      0.356703\n      0.193548\n      00:05\n    \n    \n      1\n      0.249177\n      0.256310\n      0.064516\n      00:05\n    \n    \n      2\n      0.192781\n      0.251938\n      0.032258\n      00:05\n    \n  \n\n\n\n\n\nTesting the images\n\nbird,_,probs = learn.predict(PILImage.create('duck.jpg'))\nImage.open('duck.jpg').to_thumb(256,256)\nprint(f\"This is a: {bird}.\")\nprint(f\"Probability it's a duck: {probs[0]:.4f}\")\nprint(f\"Probability it's a swan: {probs[1]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: duck.\nProbability it's a duck: 0.9990\nProbability it's a swan: 0.0010\n\n\n\nbird,_,probs = learn.predict(PILImage.create('swan.jpg'))\nImage.open('duck.jpg').to_thumb(256,256)\nprint(f\"This is a: {bird}.\")\nprint(f\"Probability it's a duck: {probs[0]:.4f}\")\nprint(f\"Probability it's a swan: {probs[1]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: swan.\nProbability it's a duck: 0.0006\nProbability it's a swan: 0.9994"
  }
]