[
  {
    "objectID": "home/index.html",
    "href": "home/index.html",
    "title": "Welcome",
    "section": "",
    "text": "I am a Telwain Daand.\nI move around in circles trying to generate value."
  },
  {
    "objectID": "rust/foundations.html",
    "href": "rust/foundations.html",
    "title": "",
    "section": "",
    "text": "Values in Rust are a combination of a type and an element in the domain of that type.\nValues are stored at a place which can be the stack, the heap or any other location.\nA pointer points to such a place. It holds the address of a region of memory.\nThe most common way to store a value is on a named value slot on the stack. We refer to this named value slot by a variable.\n\nNote: We can store the same pointer in more than one variable and thus have multiple variables that indirectly refer to the same location in memory, and thus the same underlying value.\n\n\n\n\nIn a high level model of a variable, we can think of variables as name given to a value. When we assign a value to a variable, then that value from then on is named by that variable.\nA good mental model is to imagine a dependency relationship being created between two successive access of a variable. When a variable is moved, no dependency can be mapped to it. A dependency relationship cannot be mapped from a variable that isn’t there(hasn’t been initliazed or has been moved).\nThe dependency relationships or flows trace the lifetimes of a particular instance of a value.\nThis roughly matches roughly how the compiler and the borrow checker reason about the program.\n\n\n\nVariables name memory locations that may or may not hold legal values.\nlet x: u32; // x is a name for a region in memory\nx = 6; // value 6 written to address\nIf we declare multiple variables with the same names they end up at different memory locations.\n\n\n\n\n\nStack is a region of memory that is used by a program as a scratch space for function calls. Every time a function is called a new ‘frame’ is allocated on top of the stack. It contains all the variables within the function along with the arguments the function takes. A variable stored on the frame cannot be accessed after the frame goes away(lifetime is lifetime of the frame).\n\n\n\nHeap is a pool of memory that isn’t tied to the stack of the program. This is useful when we want a value to live beyond the frame of the current function’s frame.\nSince allocations from the heap do not go away after the function, we can allocate in one function pass around the pointer to another thread and continue to safely operate of the value in the heap. The pointer has an unconstrained lifetime - its lifetime is however long the program keeps it alive.\n\n\n\nStatic memory is a catch all term for several closely related regions located in the file a program is compiled into. Values in static memory live for the duration of the program.\nStatic memory also holds the variables we define with a static keyword as well as certain constants values like strings.\nThe 'static lifetime does not create a static variable but once a reference with a static lifetime is created, it lives on till the end of the program. Whereever it pionts to might as well be in the static memory."
  },
  {
    "objectID": "rust/async-await.html",
    "href": "rust/async-await.html",
    "title": "Async/Await",
    "section": "",
    "text": "tasks voluntarily give up control to the CPU through a yield operation\ndifferent from preemptive scheduling where the OS forcibly switches between running tasks\n\nBasically comes down to:\nIf I don’t run, I’m gonna let whoever is above me decide who runs next, and it might not be me"
  },
  {
    "objectID": "rust/async-await.html#why",
    "href": "rust/async-await.html#why",
    "title": "Async/Await",
    "section": "Why?",
    "text": "Why?\n\nI/O is costly\nThreads are nice\nBut not too many\nSwitching threads = context switches, costly"
  },
  {
    "objectID": "rust/async-await.html#future-and-asyncawait",
    "href": "rust/async-await.html#future-and-asyncawait",
    "title": "Async/Await",
    "section": "Future and async/await",
    "text": "Future and async/await\n\nAsync/await let us take advantage of cooperative scheduling by allowing us to describe under what circumstances code can make progress and under what circumstances code can yield\nCooperative scheduling also means that you have to be vigilant about running blocking code in a future\n\nsee tokio::task::spawn_blocking\n\nAsync/await is rust is implemented using what is called a Future\nFuture represents a value that is not available yet.\nInstead of waiting for the value to become available, Futures allow the execution to continue till the value is needed.\nFuture has a poll method is used to initiate the resolution of the Future. Rust Futures are lazy.\n\npub trait Future {\n    type Output;\n    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;\n}\n\n/**\nOutput -> Type of the asynchronous value that the future resolves to.\nPin -> Reference which is pinned in memory\nContext -> Contains information about the Waker(responsible for letting executor\nknow about resolution of the Future)\n**/\n\nAsync/await facilitates the creation of nested Futures to better utilize CPU resources."
  },
  {
    "objectID": "rust/async-await.html#executor",
    "href": "rust/async-await.html#executor",
    "title": "Async/Await",
    "section": "Executor",
    "text": "Executor\n\nSo is it turtles all the way down?\n\nSomething has to hold all our futures\nIt can’t yield, because its a top level Future describing the flow of our application\nSo it kind of checks on all the futures in our application flow\n\nThis is what an executor does in a very basic sense\nExecutor create (e.g. tokio):\n\nprovides lowest resources on network sockets and timers\nprovides the executor loop at the top\nwired up together behind the scenes\ne.g. if we are waiting for a network socket, tokio manages all that for us\n\nThis is what happens when we wrap our Rust main function in tokio::main\n\nit kind bundles up that whole thing into an executor and handles everything to do with the OS for us, so we can focus on application logic and control flow using async await"
  },
  {
    "objectID": "rust/async-await.html#efficiency",
    "href": "rust/async-await.html#efficiency",
    "title": "Async/Await",
    "section": "Efficiency",
    "text": "Efficiency\n\nSpawn:\n\nProblem: async/await runs on 1 thread if you are not spawning anything\nspawning lets us take advantage of parallelism\n\nUnder the hood futures are implemented as state machines that contain the state of all the futures that they contain\n\nthis can become a problem when we are dealing with large states\nfutures become too big\nalternatives\n\nhave state on heap; Box our futures\nuse tokio::spawn, uses pointer to future\n\n\nasync-trait used to have traits with async functions\n\nwhy? Because its not possible for compiler to know size of futures\nasync-trait box that in a pointer for dynamic dispatch"
  },
  {
    "objectID": "rust/async-await.html#sharing-state",
    "href": "rust/async-await.html#sharing-state",
    "title": "Async/Await",
    "section": "Sharing state",
    "text": "Sharing state\n\nsharing state across Futures\n\nArc, Mutex\nclone arc and pass it into futures\n\nTokio also provides a mutex, but it is advised to use the standard library mutex as long as the critical section is short or has an await.\n\nrisk of deadlock\ntokio mutex helps but is slower"
  },
  {
    "objectID": "rust/async-await.html#cancelling-future-execution",
    "href": "rust/async-await.html#cancelling-future-execution",
    "title": "Async/Await",
    "section": "Cancelling Future execution",
    "text": "Cancelling Future execution\n\nCancellation is possible: see select macro tokio\n\nNeed to aware of all the edge cases\n\n\nThreads vs Futures:\n\ngeneral rule of thumb, use threads for compute heavy stuff\nuse async for IO applications"
  },
  {
    "objectID": "rust/async-await.html#resources-and-references",
    "href": "rust/async-await.html#resources-and-references",
    "title": "Async/Await",
    "section": "Resources and References",
    "text": "Resources and References\n\nJon Gjengset deep dive into async/await from an implementation PoV\nJon Gjengset overview of async/await from an application dev PoV\nOS rust section on async/await"
  },
  {
    "objectID": "blockchain/tdDEX.html",
    "href": "blockchain/tdDEX.html",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "",
    "text": "The tbDEX protocol facilitates the formation of networks of mutual trust between counterparties that are not centrally controlled; it allows participants to negotiate trust directly with each other (or rely on mutually trusted third-parties to vouch for counterparties), and price their exchanges to account for perceived risk and specific requirements."
  },
  {
    "objectID": "blockchain/tdDEX.html#what-is-the-aim",
    "href": "blockchain/tdDEX.html#what-is-the-aim",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "What is the aim?",
    "text": "What is the aim?\n\nbe a protocol for discovering liquidity and exchanging assets (such as bitcoin, fiat money, crypto assets or real world goods)\nutilize decentralized identity (DID) and verifiable credentials(VCs) to establish the provenance of identity in the real world\nprovides the infrastructure necessary to create a ubiquity of on-ramps and off-ramps directly between the fiat and crypto financial systems without the need for centralized intermediaries and trust brokers"
  },
  {
    "objectID": "blockchain/tdDEX.html#foundations",
    "href": "blockchain/tdDEX.html#foundations",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "Foundations",
    "text": "Foundations\n\nDIDs\n\nare a new type of identifier that enables verifiable, decentralized digital identity\nA DID refers to any subject (e.g., a person, organization, thing, data model, abstract entity, etc.) determined by the controller of the DID.\nIn contrast to typical federated identifiers, DIDs have been designed so they may be decoupled from centralized registries, identity providers, and certificate authorities.\nwhile other parties may be used to help enable the discovery of information related to a DID, the design enables the owner of a DID to prove control over it without requiring permission from any other party\n\n\n\nVCs\n\nThe Verifiable Credentials specification provides a standard way to express credentials across the digital world in a way that is cryptographically secure, privacy respecting, and machine verifiable.\nZK tech can further advance privacy and safety by preventing linkability across disclosures, reducing the amount of data disclosed, and in some cases removing the need to expose raw data values at all.\n\n\n\nIdentity Hubs\n\nFor entities to exchange messages and data for credential, app, or service flows, they need an interface through which to store, discover, and fetch data related to the flows and experiences they are participating in\nIdentity Hubs are a data storage and message relay mechanism entities can use to locate public or permissioned private data related to a given DID\nThis enables the owning entity to secure, manage, and transact their data with others without reliance on location or provider-specific infrastructure, interfaces, or routing mechanisms.\nIdentity Hubs feature semantically encoded message and data interfaces that provide inferential APIs any party can interact with simply by knowing the semantic type of data they wish to exchange. A diverse set of interactions and flows can be modeled within these interfaces by externally codifying sets of message schemas and processing directives to form meta-protocols."
  },
  {
    "objectID": "blockchain/tdDEX.html#participants",
    "href": "blockchain/tdDEX.html#participants",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "Participants",
    "text": "Participants\n\nIssuers of VCs\n\nIssuers are the source of VCs. Both individuals and organizations can be the source of VCs.\n\ne.g: a reputable organization that already conducts KYC checks could begin issuing a KYC credential to individuals\n\n\n\n\nParticipating Financial Institutions(PFIs)\n\nentities that provide liquidity services on the tdDEX network\neach PFI will be identified via DIDs and VCs\n\n\n\nWallets\n\nact as agents for individuals or institutions by facilitating exchanges with PFIs\nprovides:\n\nProviding secure encrypted storage for VCs\nPFI discovery by crawling identity hubs\napplying signatures and storing history"
  },
  {
    "objectID": "blockchain/tdDEX.html#protocol",
    "href": "blockchain/tdDEX.html#protocol",
    "title": "tbDEX: Foundations, participants and flow",
    "section": "Protocol",
    "text": "Protocol\nDivided into:\n\nRequest for Quote(RFQ): wallet broadcasts its intent to seek PFIs to exchange\nMessaging Protocol: P2P negotiation protocol which permits secure communication between a wallet and a PFI, to exchange required data and execute a transaction\n\n\nTopology and communication flow"
  },
  {
    "objectID": "fastai/lesson_1.html",
    "href": "fastai/lesson_1.html",
    "title": "Is it a duck or a swan?",
    "section": "",
    "text": "Install dependencies\n\n!pip install -Uqq fastai duckduckgo_search\n\n\n\nDefine a function to search for images on DDG. Search for 90 images by default.\n\nfrom duckduckgo_search import ddg_images\nfrom fastcore.all import *\n\ndef search_images(term, max_images=90):\n    print(f\"Searching for '{term}'\")\n    return L(ddg_images(term, max_results=max_images)).itemgot('image')\n\n\n\nLets see the an example of the URL we find using the above function\n\nurls = search_images('duck', max_images=1)\nurls[0]\n\nSearching for 'duck'\n\n\n'http://3.bp.blogspot.com/--XA3iMvaJLY/Tw_GykPs-eI/AAAAAAAAEgU/EmFKS7Cz5xQ/s1600/Duck-04.jpg'\n\n\n\n\nWhat does this image look like? Is it actually a duck?\n\nfrom fastdownload import download_url\ndest = 'duck.jpg'\ndownload_url(urls[0], dest, show_progress=False)\n\nfrom fastai.vision.all import *\nim = Image.open(dest)\nim.to_thumb(256,256)\n\n\n\n\n\n\nHow about a swan?\n\ndownload_url(search_images('swan', max_images=1)[0], 'swan.jpg', show_progress=False)\nImage.open('swan.jpg').to_thumb(256,256)\n\nSearching for 'swan'\n\n\n\n\n\n\n\nLooks like we are on the right path. So go ahead and download 90 of each. Might take a bit of time.\n\nsearches = 'duck','swan'\npath = Path('duck_or_swan')\nfrom time import sleep\n\nfor o in searches:\n    dest = (path/o)\n    dest.mkdir(exist_ok=True, parents=True)\n    download_images(dest, urls=search_images(f'{o} photo'))\n    sleep(30)  # Pause between searches to avoid over-loading server\n    resize_images(path/o, max_size=400, dest=path/o)\n\nSearching for 'duck photo'\nSearching for 'swan photo'\n\n\n\n\nRemove images that didn’t get downloaded properly\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\nlen(failed)\n\n1\n\n\n\n\nThe easiest way to use FastAI is to use define a DataBlock. We load the data from the path.\n\ndls = DataBlock(\n    blocks=(ImageBlock, CategoryBlock), \n    get_items=get_image_files, \n    splitter=RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    item_tfms=[Resize(192, method='squish')]\n).dataloaders(path, bs=32)\n\ndls.show_batch(max_n=6)\n\n\n\n\n\n\nFine tune the pre-trained resnet18 model for our data.\n\nlearn = vision_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(3)\n\n/Users/bnabi/miniforge3/envs/invokeai/lib/python3.10/site-packages/torchvision/models/_utils.py:208: UserWarning: The parameter 'pretrained' is deprecated since 0.13 and will be removed in 0.15, please use 'weights' instead.\n  warnings.warn(\n/Users/bnabi/miniforge3/envs/invokeai/lib/python3.10/site-packages/torchvision/models/_utils.py:223: UserWarning: Arguments other than a weight enum or `None` for 'weights' are deprecated since 0.13 and will be removed in 0.15. The current behavior is equivalent to passing `weights=ResNet18_Weights.IMAGENET1K_V1`. You can also use `weights=ResNet18_Weights.DEFAULT` to get the most up-to-date weights.\n  warnings.warn(msg)\n\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      error_rate\n      time\n    \n  \n  \n    \n      0\n      1.222246\n      0.440960\n      0.290323\n      00:04\n    \n  \n\n\n\n\n\n\n\n\n\n  \n    \n      epoch\n      train_loss\n      valid_loss\n      error_rate\n      time\n    \n  \n  \n    \n      0\n      0.402388\n      0.356703\n      0.193548\n      00:05\n    \n    \n      1\n      0.249177\n      0.256310\n      0.064516\n      00:05\n    \n    \n      2\n      0.192781\n      0.251938\n      0.032258\n      00:05\n    \n  \n\n\n\n\n\nTesting the images\n\nbird,_,probs = learn.predict(PILImage.create('duck.jpg'))\nImage.open('duck.jpg').to_thumb(256,256)\nprint(f\"This is a: {bird}.\")\nprint(f\"Probability it's a duck: {probs[0]:.4f}\")\nprint(f\"Probability it's a swan: {probs[1]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: duck.\nProbability it's a duck: 0.9990\nProbability it's a swan: 0.0010\n\n\n\nbird,_,probs = learn.predict(PILImage.create('swan.jpg'))\nImage.open('duck.jpg').to_thumb(256,256)\nprint(f\"This is a: {bird}.\")\nprint(f\"Probability it's a duck: {probs[0]:.4f}\")\nprint(f\"Probability it's a swan: {probs[1]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: swan.\nProbability it's a duck: 0.0006\nProbability it's a swan: 0.9994"
  }
]